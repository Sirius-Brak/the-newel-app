from flask import Flask, render_template, request, redirect, url_for, flash, session
import sqlite3
import os
from dotenv import load_dotenv
import random  # <-- ADD THIS LINE
from werkzeug.security import generate_password_hash, check_password_hash
from functools import wraps
from datetime import datetime

# Science facts list
SCIENCE_FACTS = [
    "Matter is made of atoms, which consist of protons, neutrons, and electrons, but most of an atom is empty space.",
    "Energy cannot be created or destroyed, only converted from one form to another (conservation of energy).",
    "The speed of light in a vacuum is constant at approximately 299,792,458 meters per second - nothing can travel faster.",
    "Quantum mechanics shows that particles can exist in multiple states simultaneously until observed (superposition).",
    "The universe is approximately 13.8 billion years old and is still expanding.",
    "Black holes are regions where gravity is so strong that not even light can escape.",
    "All life on Earth shares a common ancestor and evolved through natural selection over billions of years.",
    "DNA carries genetic information in all living organisms and is made of four bases: A, T, G, and C.",
    "Cells are the basic units of life, and all cells come from pre-existing cells.",
    "Photosynthesis converts sunlight, carbon dioxide, and water into glucose and oxygen, powering most life on Earth.",
    "Viruses are not technically alive - they require host cells to reproduce.",
    "The human body contains roughly the same number of bacterial cells as human cells.",
    "Earth's climate is changing due to increased greenhouse gases from human activities, primarily carbon dioxide.",
    "Continental drift and plate tectonics explain how continents move and why earthquakes and volcanoes occur.",
    "The water cycle continuously moves water between oceans, atmosphere, and land through evaporation, condensation, and precipitation.",
    "Earth's magnetic field protects us from harmful solar radiation and is generated by its molten iron core.",
    "Fossil fuels formed from ancient organic matter over millions of years and are non-renewable resources.",
    "The human brain contains approximately 86 billion neurons connected by trillions of synapses.",
    "Neuroplasticity means the brain can reorganize and form new neural connections throughout life.",
    "Memory is not like a recording device - it's reconstructed each time we recall something, making it fallible.",
    "The placebo effect demonstrates the powerful connection between mind and body in healing.",
    "Computers process information using binary code (0s and 1s) and perform calculations through logic gates.",
    "The internet is a global network of interconnected computers that communicate using standardized protocols.",
    "Artificial intelligence and machine learning allow computers to learn patterns from data without explicit programming.",
    "CRISPR gene editing technology allows precise modification of DNA sequences in living organisms.",
    "Vaccines work by training the immune system to recognize and fight specific pathogens without causing disease.",
    "Antibiotics only work against bacterial infections, not viral infections like the common cold or flu.",
    "Cancer occurs when cells grow uncontrollably due to genetic mutations that accumulate over time.",
    "The human genome contains about 3 billion base pairs of DNA and roughly 20,000-25,000 genes.",
    "Our solar system is located in the Milky Way galaxy, which contains over 100 billion stars.",
    "Exoplanets (planets outside our solar system) are common - scientists have discovered thousands orbiting other stars.",
    "Dark matter and dark energy make up about 95% of the universe, but we still don't fully understand what they are.",
    "Time passes differently depending on gravity and speed, as explained by Einstein's theory of relativity."
]

# Get the absolute path to the current directory
basedir = os.path.abspath(os.path.dirname(__file__))
DATABASE_PATH = os.path.join(basedir, 'instance', 'the_newel.db')
TEMPLATES_PATH = os.path.join(basedir, 'templates')

app = Flask(__name__, template_folder=TEMPLATES_PATH)
load_dotenv() # Loads the variables from the .env file
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY') # Gets the key from the .env file

# Helper function to get a database connection
def get_db():
    conn = sqlite3.connect(DATABASE_PATH)
    conn.row_factory = sqlite3.Row
    return conn

# Login required decorator
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            flash('Please log in to access this page.', 'error')
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function

# Registration for both Teachers and Students
@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        full_name = request.form.get('full_name')
        username = request.form.get('username')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')
        role = request.form.get('role', 'teacher')
        student_class = request.form.get('class')

        # Validation
        if not all([full_name, username, password, confirm_password]):
            flash('All fields are required.', 'error')
            return render_template('auth/register.html', role=role)
        
        if password != confirm_password:
            flash('Passwords do not match.', 'error')
            return render_template('auth/register.html', role=role)

        # Hash the password
        hashed_password = generate_password_hash(password)

        # Insert into database
        conn = None
        try:
            conn = get_db()
            cursor = conn.cursor()
            
            # Check if username already exists
            cursor.execute("SELECT id FROM users WHERE username = ?", (username,))
            if cursor.fetchone():
                flash('Username already exists. Please choose another.', 'error')
                return render_template('auth/register.html', role=role)
            
            # Insert new user (simplified to handle class for students)
            cursor.execute(
                "INSERT INTO users (full_name, username, password_hash, role, class) VALUES (?, ?, ?, ?, ?)",
                (full_name, username, hashed_password, role, student_class if role == 'student' else None)
            )
            
            conn.commit()
            flash('Registration successful! Please log in with your credentials.', 'success')
            return redirect(url_for('login'))
            
        except sqlite3.Error as e:
            flash(f'An error occurred: {str(e)}', 'error')
            return render_template('auth/register.html', role=role)
        finally:
            if conn:
                conn.close()

    # GET request - show the form with default role
    role = request.args.get('role', 'teacher')
    return render_template('auth/register.html', role=role)

# Login for both Teachers and Students
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')

        # Validation
        if not all([username, password]):
            flash('Please enter both username and password.', 'error')
            return render_template('auth/login.html')

        # Check user credentials
        conn = None
        try:
            conn = get_db()
            cursor = conn.cursor()
            
            # Find user by username
            cursor.execute("SELECT * FROM users WHERE username = ?", (username,))
            user = cursor.fetchone()
            
            if user and check_password_hash(user['password_hash'], password):
                # Successful login - set session
                session['user_id'] = user['id']
                session['username'] = user['username']
                session['full_name'] = user['full_name']
                session['role'] = user['role']
                session['class'] = user['class']  # Store class in session
                
                flash('Login successful!', 'success')
                if user['role'] == 'teacher':
                    return redirect(url_for('teacher_dashboard'))
                else:
                    return redirect(url_for('student_dashboard'))
            else:
                flash('Invalid username or password.', 'error')
                return render_template('auth/login.html')
            
        except sqlite3.Error as e:
            flash(f'An error occurred: {str(e)}', 'error')
            return render_template('auth/login.html')
        finally:
            if conn:
                conn.close()

    # GET request - show the form
    return render_template('auth/login.html')

# Teacher Dashboard
@app.route('/teacher-dashboard')
@login_required
def teacher_dashboard():
    if session.get('role') != 'teacher':
        flash('Access denied. Teacher authorization required.', 'error')
        return redirect(url_for('index'))
    
    return render_template('teacher/dashboard.html')

# Student Dashboard
@app.route('/student-dashboard')
@login_required
def student_dashboard():
    if session.get('role') != 'student':
        flash('Access denied. Student authorization required.', 'error')
        return redirect(url_for('index'))
    
    return render_template('student/dashboard.html')

# Student Physics Prompts
@app.route('/student-physics-prompts')
@login_required
def student_physics_prompts():
    if session.get('role') != 'student':
        flash('Access denied. Student authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        # Get prompts for the student's year
        cursor.execute("""
            SELECT p.*, 
                   EXISTS (SELECT 1 FROM submissions WHERE prompt_id = p.id AND student_id = ?) as submitted
            FROM prompts p
            WHERE p.subject = 'physics' AND p.class_year = ?
            ORDER BY p.created_at DESC
        """, (session['user_id'], session['class']))  # Use the full class name, e.g., "Year 7"
        prompts = cursor.fetchall()
    except sqlite3.Error as e:
        flash(f'Error retrieving prompts: {str(e)}', 'error')
        prompts = []
    finally:
        if conn:
            conn.close()
    
    return render_template('student/physics_prompts.html', prompts=prompts)

# View Physics Prompt for Students
@app.route('/student-physics-prompt/<int:prompt_id>')
@login_required
def view_student_physics_prompt(prompt_id):
    if session.get('role') != 'student':
        flash('Access denied. Student authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM prompts WHERE id = ? AND class_year = ?
        """, (prompt_id, session['class']))
        prompt = cursor.fetchone()
        
        if not prompt:
            flash('Prompt not found or access denied.', 'error')
            return redirect(url_for('student_physics_prompts'))
            
    except sqlite3.Error as e:
        flash(f'Error retrieving prompt: {str(e)}', 'error')
        return redirect(url_for('student_physics_prompts'))
    finally:
        if conn:
            conn.close()
    
    return render_template('student/view_physics_prompt.html', prompt=prompt)

# Submit Physics Response
@app.route('/submit-physics-response/<int:prompt_id>', methods=['GET', 'POST'])
@login_required
def submit_physics_response(prompt_id):
    if session.get('role') != 'student':
        flash('Access denied. Student authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        
        # Check if prompt exists and is for the student's year
        cursor.execute("SELECT * FROM prompts WHERE id = ? AND class_year = ?", (prompt_id, session['class']))
        prompt = cursor.fetchone()
        if not prompt:
            flash('Prompt not found or access denied.', 'error')
            return redirect(url_for('student_physics_prompts'))
        
        # Check if already submitted
        cursor.execute("SELECT * FROM submissions WHERE prompt_id = ? AND student_id = ?", (prompt_id, session['user_id']))
        submission = cursor.fetchone()
        if submission:
            flash('You have already submitted a response for this prompt.', 'error')
            return redirect(url_for('view_student_physics_prompt', prompt_id=prompt_id))
        
        if request.method == 'POST':
            response_text = request.form.get('response_text')
            if not response_text:
                flash('Response text is required.', 'error')
                return render_template('student/submit_response.html', prompt=prompt)
            
            # Insert submission
            cursor.execute("""
                INSERT INTO submissions (prompt_id, student_id, response_text, submitted_at)
                VALUES (?, ?, ?, ?)
            """, (prompt_id, session['user_id'], response_text, datetime.now()))
            conn.commit()
            flash('Response submitted successfully!', 'success')
            return redirect(url_for('view_student_physics_prompt', prompt_id=prompt_id))
        
    except sqlite3.Error as e:
        flash(f'An error occurred: {str(e)}', 'error')
        return redirect(url_for('student_physics_prompts'))
    finally:
        if conn:
            conn.close()
    
    return render_template('student/submit_response.html', prompt=prompt)

# Physics Prompts Dashboard
@app.route('/physics-prompts')
@login_required
def physics_prompts():
    if session.get('role') != 'teacher':
        flash('Access denied. Teacher authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM prompts 
            WHERE subject = 'physics' AND created_by = ?
            ORDER BY created_at DESC
        """, (session['user_id'],))
        prompts = cursor.fetchall()
    except sqlite3.Error as e:
        flash(f'Error retrieving prompts: {str(e)}', 'error')
        prompts = []
    finally:
        if conn:
            conn.close()
    
    return render_template('teacher/physics_prompts.html', prompts=prompts)

# Create Physics Prompt
@app.route('/create-physics-prompt', methods=['GET', 'POST'])
@login_required
def create_physics_prompt():
    if session.get('role') != 'teacher':
        flash('Access denied. Teacher authorization required.', 'error')
        return redirect(url_for('index'))
    
    if request.method == 'POST':
        title = request.form.get('title')
        description = request.form.get('description')
        class_year = request.form.get('class_year')
        
        if not all([title, description, class_year]):
            flash('All fields are required.', 'error')
            return render_template('teacher/create_physics_prompt.html')
        
        conn = None
        try:
            conn = get_db()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO prompts (title, description, subject, class_year, created_by)
                VALUES (?, ?, ?, ?, ?)
            """, (title, description, 'physics', class_year, session['user_id']))
            conn.commit()
            flash('Physics prompt created successfully!', 'success')
            return redirect(url_for('physics_prompts'))
        except sqlite3.Error as e:
            flash(f'Error creating prompt: {str(e)}', 'error')
            return render_template('teacher/create_physics_prompt.html')
        finally:
            if conn:
                conn.close()
    
    return render_template('teacher/create_physics_prompt.html')

# View Physics Prompt
@app.route('/physics-prompt/<int:prompt_id>')
@login_required
def view_physics_prompt(prompt_id):
    if session.get('role') != 'teacher':
        flash('Access denied. Teacher authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM prompts WHERE id = ? AND created_by = ?
        """, (prompt_id, session['user_id']))
        prompt = cursor.fetchone()
        
        if not prompt:
            flash('Prompt not found or access denied.', 'error')
            return redirect(url_for('physics_prompts'))
            
    except sqlite3.Error as e:
        flash(f'Error retrieving prompt: {str(e)}', 'error')
        return redirect(url_for('physics_prompts'))
    finally:
        if conn:
            conn.close()
    
    return render_template('teacher/view_physics_prompt.html', prompt=prompt)

# Delete Physics Prompt
@app.route('/delete-physics-prompt/<int:prompt_id>')
@login_required
def delete_physics_prompt(prompt_id):
    if session.get('role') != 'teacher':
        flash('Access denied. Teacher authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute("""
            DELETE FROM prompts WHERE id = ? AND created_by = ?
        """, (prompt_id, session['user_id']))
        conn.commit()
        
        if cursor.rowcount > 0:
            flash('Prompt deleted successfully!', 'success')
        else:
            flash('Prompt not found or access denied.', 'error')
            
    except sqlite3.Error as e:
        flash(f'Error deleting prompt: {str(e)}', 'error')
    finally:
        if conn:
            conn.close()
    
    return redirect(url_for('physics_prompts'))

# View Submissions for a Prompt (Grading Interface)
@app.route('/physics-prompt/<int:prompt_id>/submissions')
@login_required
def view_prompt_submissions(prompt_id):
    if session.get('role') != 'teacher':
        flash('Access denied.', 'error')
        return redirect(url_for('index'))
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM prompts WHERE id = ? AND created_by = ?", (prompt_id, session['user_id']))
        prompt = cursor.fetchone()
        if not prompt:
            flash('Prompt not found.', 'error')
            return redirect(url_for('physics_prompts'))
        
        # Get all submissions for this prompt, with student info
        cursor.execute("""
            SELECT s.*, u.full_name, u.class
            FROM submissions s
            JOIN users u ON s.student_id = u.id
            WHERE s.prompt_id = ?
            ORDER BY s.submitted_at DESC
        """, (prompt_id,))
        submissions = cursor.fetchall()
        
    except sqlite3.Error as e:
        flash(f'Error: {str(e)}', 'error')
        submissions = []
    finally:
        if conn:
            conn.close()
    return render_template('teacher/prompt_submissions.html', prompt=prompt, submissions=submissions)

# Biology Prompts Dashboard
@app.route('/biology-prompts')
@login_required
def biology_prompts():
    if session.get('role') != 'teacher':
        flash('Access denied. Teacher authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM prompts 
            WHERE subject = 'biology' AND created_by = ?
            ORDER BY created_at DESC
        """, (session['user_id'],))
        prompts = cursor.fetchall()
    except sqlite3.Error as e:
        flash(f'Error retrieving prompts: {str(e)}', 'error')
        prompts = []
    finally:
        if conn:
            conn.close()
    
    return render_template('teacher/biology_prompts.html', prompts=prompts)

# Create Biology Prompt
@app.route('/create-biology-prompt', methods=['GET', 'POST'])
@login_required
def create_biology_prompt():
    if session.get('role') != 'teacher':
        flash('Access denied. Teacher authorization required.', 'error')
        return redirect(url_for('index'))
    
    if request.method == 'POST':
        title = request.form.get('title')
        description = request.form.get('description')
        class_year = request.form.get('class_year')
        
        if not all([title, description, class_year]):
            flash('All fields are required.', 'error')
            return render_template('teacher/create_biology_prompt.html')
        
        conn = None
        try:
            conn = get_db()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO prompts (title, description, subject, class_year, created_by)
                VALUES (?, ?, ?, ?, ?)
            """, (title, description, 'biology', class_year, session['user_id']))
            conn.commit()
            flash('Biology prompt created successfully!', 'success')
            return redirect(url_for('biology_prompts'))
        except sqlite3.Error as e:
            flash(f'Error creating prompt: {str(e)}', 'error')
            return render_template('teacher/create_biology_prompt.html')
        finally:
            if conn:
                conn.close()
    
    return render_template('teacher/create_biology_prompt.html')

# Student Biology Prompts
@app.route('/student-biology-prompts')
@login_required
def student_biology_prompts():
    if session.get('role') != 'student':
        flash('Access denied. Student authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        # Get biology prompts for the student's year (fixed: extract year number)
        cursor.execute("""
    SELECT p.*, 
           EXISTS (SELECT 1 FROM submissions WHERE prompt_id = p.id AND student_id = ?) as submitted
    FROM prompts p
    WHERE p.subject = 'biology' AND p.class_year = ?
    ORDER BY p.created_at DESC
""", (session['user_id'], session['class'].split()[-1]))  # Fixed: Extract just the number
        prompts = cursor.fetchall()
    except sqlite3.Error as e:
        flash(f'Error retrieving prompts: {str(e)}', 'error')
        prompts = []
    finally:
        if conn:
            conn.close()
    
    return render_template('student/biology_prompts.html', prompts=prompts)

# Grade a Submission
@app.route('/grade-submission/<int:submission_id>', methods=['POST'])
@login_required
def grade_submission(submission_id):
    if session.get('role') != 'teacher':
        flash('Access denied. Teacher authorization required.', 'error')
        return redirect(url_for('index'))
    
    # Get the score from the form
    score = request.form.get('score', type=int)
    
    # Basic validation
    if score is None or score < 0 or score > 100:
        flash('Please enter a valid score between 0 and 100.', 'error')
        return redirect(request.referrer or url_for('teacher_dashboard'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        
        # Verify the teacher has permission to grade this submission
        # (The prompt for this submission must belong to the teacher)
        cursor.execute("""
            SELECT s.*, p.created_by 
            FROM submissions s
            JOIN prompts p ON s.prompt_id = p.id
            WHERE s.id = ?
        """, (submission_id,))
        submission = cursor.fetchone()
        
        if not submission or submission['created_by'] != session['user_id']:
            flash('Submission not found or access denied.', 'error')
            return redirect(url_for('physics_prompts'))
        
        # Update the submission with the score
        cursor.execute("""
            UPDATE submissions 
            SET score = ?
            WHERE id = ?
        """, (score, submission_id))
        conn.commit()
        
        flash(f'Score of {score} submitted successfully!', 'success')
        
    except sqlite3.Error as e:
        flash(f'Error updating score: {str(e)}', 'error')
    finally:
        if conn:
            conn.close()
    
    # Redirect back to the submissions page for the prompt
    return redirect(url_for('view_prompt_submissions', prompt_id=submission['prompt_id']))

# Leaderboard - Shows student rankings based on average scores
@app.route('/leaderboard')
@login_required
def leaderboard():
    # Get optional class filter from query parameters
    class_filter = request.args.get('class', '')
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        
        # Base query with optional class filter
        query = """
            SELECT 
                u.id, 
                u.full_name, 
                u.class,
                COUNT(s.id) as submissions_count,
                AVG(s.score) as average_score
            FROM users u
            LEFT JOIN submissions s ON u.id = s.student_id
            WHERE u.role = 'student'
        """
        
        params = []
        if class_filter:
            query += " AND u.class = ?"
            params.append(class_filter)
        
        query += """
            GROUP BY u.id
            HAVING submissions_count > 0
            ORDER BY average_score DESC
        """
        
        cursor.execute(query, params)
        leaderboard_data = cursor.fetchall()
        
        # Get distinct classes for the filter dropdown (for teachers)
        distinct_classes = []
        if session.get('role') == 'teacher':
            cursor.execute("SELECT DISTINCT class FROM users WHERE class IS NOT NULL AND role = 'student' ORDER BY class")
            distinct_classes = [row['class'] for row in cursor.fetchall()]
        
    except sqlite3.Error as e:
        flash(f'Error retrieving leaderboard: {str(e)}', 'error')
        leaderboard_data = []
        distinct_classes = []
    finally:
        if conn:
            conn.close()
    
    return render_template('leaderboard.html', 
                         leaderboard_data=leaderboard_data,
                         distinct_classes=distinct_classes,
                         current_class=class_filter,
                         user_role=session.get('role'))

# Logout
@app.route('/logout')
def logout():
    session.clear()
    flash('You have been logged out successfully.', 'success')
    return redirect(url_for('index'))

# The Homepage
@app.route('/')
def index():
    random_fact = random.choice(SCIENCE_FACTS)
    return render_template('index.html', random_fact=random_fact)

# History - View past submissions
@app.route('/history')
@login_required
def history():
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        
        if session.get('role') == 'teacher':
            # Teacher sees all submissions with student and prompt info
            cursor.execute("""
                SELECT s.*, u.full_name as student_name, u.class, p.title as prompt_title
                FROM submissions s
                JOIN users u ON s.student_id = u.id
                JOIN prompts p ON s.prompt_id = p.id
                ORDER BY s.submitted_at DESC
            """)
            submissions = cursor.fetchall()
        else:
            # Student sees only their own submissions
            cursor.execute("""
                SELECT s.*, p.title as prompt_title
                FROM submissions s
                JOIN prompts p ON s.prompt_id = p.id
                WHERE s.student_id = ?
                ORDER BY s.submitted_at DESC
            """, (session['user_id'],))
            submissions = cursor.fetchall()
        
    except sqlite3.Error as e:
        flash(f'Error retrieving history: {str(e)}', 'error')
        submissions = []
    finally:
        if conn:
            conn.close()
    
    return render_template('history.html', submissions=submissions, user_role=session.get('role'))

# Class Management - View students organized by class
@app.route('/class-management')
@login_required
def class_management():
    if session.get('role') != 'teacher':
        flash('Access denied. Teacher authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        
        # Get all classes with student counts and average performance
        cursor.execute("""
            SELECT 
                class,
                COUNT(*) as student_count,
                AVG((SELECT AVG(score) FROM submissions WHERE student_id = users.id AND score IS NOT NULL)) as class_average
            FROM users 
            WHERE role = 'student' AND class IS NOT NULL 
            GROUP BY class 
            ORDER BY class
        """)
        class_stats = cursor.fetchall()
        
        # Get all students with their performance data
        cursor.execute("""
            SELECT 
                u.id, u.full_name, u.class, u.created_at,
                COUNT(s.id) as submission_count,
                AVG(s.score) as average_score
            FROM users u
            LEFT JOIN submissions s ON u.id = s.student_id
            WHERE u.role = 'student'
            GROUP BY u.id
            ORDER BY u.class, u.full_name
        """)
        all_students = cursor.fetchall()
        
    except sqlite3.Error as e:
        flash(f'Error retrieving class data: {str(e)}', 'error')
        class_stats = []
        all_students = []
    finally:
        if conn:
            conn.close()
    
    # Organize students by class
    students_by_class = {}
    for student in all_students:
        class_name = student['class'] or 'Ungrouped'
        if class_name not in students_by_class:
            students_by_class[class_name] = []
        students_by_class[class_name].append(student)
    
    return render_template('teacher/class_management.html', 
                         class_stats=class_stats,
                         students_by_class=students_by_class)

# View Biology Prompt for Teachers
@app.route('/biology-prompt/<int:prompt_id>')
@login_required
def view_biology_prompt(prompt_id):
    if session.get('role') != 'teacher':
        flash('Access denied. Teacher authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM prompts WHERE id = ? AND created_by = ? AND subject = 'biology'
        """, (prompt_id, session['user_id']))
        prompt = cursor.fetchone()
        
        if not prompt:
            flash('Prompt not found or access denied.', 'error')
            return redirect(url_for('biology_prompts'))
            
    except sqlite3.Error as e:
        flash(f'Error retrieving prompt: {str(e)}', 'error')
        return redirect(url_for('biology_prompts'))
    finally:
        if conn:
            conn.close()
    
    return render_template('teacher/view_biology_prompt.html', prompt=prompt)

# View Biology Prompt for Students
@app.route('/student-biology-prompt/<int:prompt_id>')
@login_required
def view_student_biology_prompt(prompt_id):
    if session.get('role') != 'student':
        flash('Access denied. Student authorization required.', 'error')
        return redirect(url_for('index'))
    
    # Extract year number from class (e.g., "Year 9" -> "9")
    student_year = session['class'].split()[-1] if session['class'] else ""
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM prompts 
            WHERE id = ? AND class_year = ? AND subject = 'biology'
        """, (prompt_id, student_year))
        prompt = cursor.fetchone()
        
        if not prompt:
            flash('Biology prompt not found or access denied.', 'error')
            return redirect(url_for('student_biology_prompts'))
            
    except sqlite3.Error as e:
        flash(f'Error retrieving prompt: {str(e)}', 'error')
        return redirect(url_for('student_biology_prompts'))
    finally:
        if conn:
            conn.close()
    
    return render_template('student/view_biology_prompt.html', prompt=prompt)

# Submit Biology Response
@app.route('/submit-biology-response/<int:prompt_id>', methods=['GET', 'POST'])
@login_required
def submit_biology_response(prompt_id):
    if session.get('role') != 'student':
        flash('Access denied. Student authorization required.', 'error')
        return redirect(url_for('index'))
    
    # Extract year number from class (e.g., "Year 9" -> "9")
    student_year = session['class'].split()[-1] if session['class'] else ""
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        
        # Check if prompt exists and is for the student's year
        cursor.execute("SELECT * FROM prompts WHERE id = ? AND class_year = ? AND subject = 'biology'", (prompt_id, student_year))
        prompt = cursor.fetchone()
        if not prompt:
            flash('Biology prompt not found or access denied.', 'error')
            return redirect(url_for('student_biology_prompts'))
        
        # Check if already submitted
        cursor.execute("SELECT * FROM submissions WHERE prompt_id = ? AND student_id = ?", (prompt_id, session['user_id']))
        submission = cursor.fetchone()
        if submission:
            flash('You have already submitted a response for this biology prompt.', 'error')
            return redirect(url_for('view_student_biology_prompt', prompt_id=prompt_id))
        
        if request.method == 'POST':
            response_text = request.form.get('response_text')
            if not response_text:
                flash('Response text is required.', 'error')
                return render_template('student/submit_biology_response.html', prompt=prompt)
            
            # Insert submission
            cursor.execute("""
                INSERT INTO submissions (prompt_id, student_id, response_text, submitted_at)
                VALUES (?, ?, ?, ?)
            """, (prompt_id, session['user_id'], response_text, datetime.now()))
            conn.commit()
            flash('Biology response submitted successfully!', 'success')
            return redirect(url_for('view_student_biology_prompt', prompt_id=prompt_id))
        
    except sqlite3.Error as e:
        flash(f'An error occurred: {str(e)}', 'error')
        return redirect(url_for('student_biology_prompts'))
    finally:
        if conn:
            conn.close()
    
    return render_template('student/submit_biology_response.html', prompt=prompt)

# General Prompts Dashboard
@app.route('/general-prompts')
@login_required
def general_prompts():
    if session.get('role') != 'teacher':
        flash('Access denied. Teacher authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM prompts 
            WHERE subject = 'general' AND created_by = ?
            ORDER BY created_at DESC
        """, (session['user_id'],))
        prompts = cursor.fetchall()
    except sqlite3.Error as e:
        flash(f'Error retrieving prompts: {str(e)}', 'error')
        prompts = []
    finally:
        if conn:
            conn.close()
    
    return render_template('teacher/general_prompts.html', prompts=prompts)

# Create General Prompt
@app.route('/create-general-prompt', methods=['GET', 'POST'])
@login_required
def create_general_prompt():
    if session.get('role') != 'teacher':
        flash('Access denied. Teacher authorization required.', 'error')
        return redirect(url_for('index'))
    
    if request.method == 'POST':
        title = request.form.get('title')
        description = request.form.get('description')
        
        if not all([title, description]):
            flash('All fields are required.', 'error')
            return render_template('teacher/create_general_prompt.html')
        
        conn = None
        try:
            conn = get_db()
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO prompts (title, description, subject, class_year, created_by)
                VALUES (?, ?, ?, ?, ?)
            """, (title, description, 'general', 'all', session['user_id']))
            conn.commit()
            flash('General prompt created successfully!', 'success')
            return redirect(url_for('general_prompts'))
        except sqlite3.Error as e:
            flash(f'Error creating prompt: {str(e)}', 'error')
            return render_template('teacher/create_general_prompt.html')
        finally:
            if conn:
                conn.close()
    
    return render_template('teacher/create_general_prompt.html')

# Student General Prompts
@app.route('/student-general-prompts')
@login_required
def student_general_prompts():
    if session.get('role') != 'student':
        flash('Access denied. Student authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        # Get general prompts (available to all students)
        cursor.execute("""
            SELECT p.*, 
                   EXISTS (SELECT 1 FROM submissions WHERE prompt_id = p.id AND student_id = ?) as submitted
            FROM prompts p
            WHERE p.subject = 'general'
            ORDER BY p.created_at DESC
        """, (session['user_id'],))
        prompts = cursor.fetchall()
    except sqlite3.Error as e:
        flash(f'Error retrieving prompts: {str(e)}', 'error')
        prompts = []
    finally:
        if conn:
            conn.close()
    
    return render_template('student/general_prompts.html', prompts=prompts)

# General Leaderboard - Shows rankings for general prompts only
@app.route('/general-leaderboard')
@login_required
def general_leaderboard():
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        
        # Get rankings for general prompts only
        cursor.execute("""
            SELECT 
                u.id, 
                u.full_name, 
                u.class,
                COUNT(s.id) as submissions_count,
                AVG(s.score) as average_score
            FROM users u
            JOIN submissions s ON u.id = s.student_id
            JOIN prompts p ON s.prompt_id = p.id
            WHERE u.role = 'student' AND p.subject = 'general'
            GROUP BY u.id
            HAVING submissions_count > 0
            ORDER BY average_score DESC
        """)
        leaderboard_data = cursor.fetchall()
        
    except sqlite3.Error as e:
        flash(f'Error retrieving leaderboard: {str(e)}', 'error')
        leaderboard_data = []
    finally:
        if conn:
            conn.close()
    
    return render_template('general_leaderboard.html', 
                         leaderboard_data=leaderboard_data,
                         user_role=session.get('role'))

# View General Prompt for Students
@app.route('/student-general-prompt/<int:prompt_id>')
@login_required
def view_student_general_prompt(prompt_id):
    if session.get('role') != 'student':
        flash('Access denied. Student authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT * FROM prompts WHERE id = ? AND subject = 'general'
        """, (prompt_id,))
        prompt = cursor.fetchone()
        
        if not prompt:
            flash('General prompt not found.', 'error')
            return redirect(url_for('student_general_prompts'))
            
        # Check if already submitted
        cursor.execute("SELECT * FROM submissions WHERE prompt_id = ? AND student_id = ?", (prompt_id, session['user_id']))
        submission = cursor.fetchone()
            
    except sqlite3.Error as e:
        flash(f'Error retrieving prompt: {str(e)}', 'error')
        return redirect(url_for('student_general_prompts'))
    finally:
        if conn:
            conn.close()
    
    return render_template('student/view_general_prompt.html', prompt=prompt, submission=submission)

# Submit General Response
@app.route('/submit-general-response/<int:prompt_id>', methods=['GET', 'POST'])
@login_required
def submit_general_response(prompt_id):
    if session.get('role') != 'student':
        flash('Access denied. Student authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        
        # Check if prompt exists
        cursor.execute("SELECT * FROM prompts WHERE id = ? AND subject = 'general'", (prompt_id,))
        prompt = cursor.fetchone()
        if not prompt:
            flash('General prompt not found.', 'error')
            return redirect(url_for('student_general_prompts'))
        
        # Check if already submitted
        cursor.execute("SELECT * FROM submissions WHERE prompt_id = ? AND student_id = ?", (prompt_id, session['user_id']))
        existing_submission = cursor.fetchone()
        if existing_submission:
            flash('You have already submitted a response for this challenge.', 'error')
            return redirect(url_for('view_student_general_prompt', prompt_id=prompt_id))
        
        if request.method == 'POST':
            response_text = request.form.get('response_text')
            if not response_text:
                flash('Response text is required.', 'error')
                return render_template('student/submit_general_response.html', prompt=prompt)
            
            # Insert submission
            cursor.execute("""
                INSERT INTO submissions (prompt_id, student_id, response_text, submitted_at)
                VALUES (?, ?, ?, ?)
            """, (prompt_id, session['user_id'], response_text, datetime.now()))
            conn.commit()
            flash('Response submitted successfully!', 'success')
            return redirect(url_for('view_student_general_prompt', prompt_id=prompt_id))
        
    except sqlite3.Error as e:
        flash(f'An error occurred: {str(e)}', 'error')
        return redirect(url_for('student_general_prompts'))
    finally:
        if conn:
            conn.close()
    
    return render_template('student/submit_general_response.html', prompt=prompt)

# View General Prompt Submissions for Teachers
@app.route('/general-prompt/<int:prompt_id>/submissions')
@login_required
def view_general_prompt_submissions(prompt_id):
    if session.get('role') != 'teacher':
        flash('Access denied. Teacher authorization required.', 'error')
        return redirect(url_for('index'))
    
    conn = None
    try:
        conn = get_db()
        cursor = conn.cursor()
        
        # Verify the prompt belongs to the teacher
        cursor.execute("SELECT * FROM prompts WHERE id = ? AND created_by = ? AND subject = 'general'", (prompt_id, session['user_id']))
        prompt = cursor.fetchone()
        if not prompt:
            flash('Prompt not found.', 'error')
            return redirect(url_for('general_prompts'))
        
        # Get all submissions for this prompt
        cursor.execute("""
            SELECT s.*, u.full_name, u.class
            FROM submissions s
            JOIN users u ON s.student_id = u.id
            WHERE s.prompt_id = ?
            ORDER BY s.submitted_at DESC
        """, (prompt_id,))
        submissions = cursor.fetchall()
        
    except sqlite3.Error as e:
        flash(f'Error: {str(e)}', 'error')
        submissions = []
    finally:
        if conn:
            conn.close()
    
    return render_template('teacher/general_prompt_submissions.html', prompt=prompt, submissions=submissions)

if __name__ == '__main__':
    print("Starting The Newel app server...")
    print(f"Database path: {DATABASE_PATH}")
    print(f"Templates path: {TEMPLATES_PATH}")
    app.run(debug=True)